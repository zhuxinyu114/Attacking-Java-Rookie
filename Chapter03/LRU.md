# LRU

LRU，最近最少使用，把数据加入一个链表中，按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉。

比如有数据 1，2，1，3，2

此时缓存中已有（1，2）

当3加入的时候，得把后面的2淘汰，变成（3，1）

显然

LRU对于循环出现的数据，缓存命中不高

比如，这样的数据，1，1，1，2，2，2，3，4，1，1，1，2，2，2.....

当走到3，4的时候，1，2会被淘汰掉，但是后面还有很多1，2


### LFU的一个实现方法：

用一个主双向链表记录（访问次数，从链表头），从链表中按时间顺序记录着（key）
用一个哈希表记录（key，(value, 主链表ptr，从链表ptr)）ptr表示该key在链表中的地址
然后，get，put都在哈希表中操作，近似O(1)，哈希表中有个节点在链表中的地址，能O(1)找到，并把节点提搞访问频次，链表插入删除也都是O(1)。

